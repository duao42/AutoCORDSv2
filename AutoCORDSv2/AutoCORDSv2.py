import argparse
import os
import sys
import logging
import time
import multiprocessing
import re
import subprocess

from Bio import SeqIO

import conserve
import primers
import specificity
import crRNAs


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", metavar='Input', type=str, required=True, help="Path of input file")
    parser.add_argument("-t", metavar='Type', type=str, required=True, help="fasta/MSA_fasta."
                                                                            "Multiple genome files or Multiple sequence"
                                                                            " alignment files generated by Clustal "
                                                                            "Omega（The default name of MSA file that "
                                                                            "generated by this "
                                                                            "programe is ’alignment.fasta‘）")
    parser.add_argument("-cl", metavar='crRNA Length', type=int, required=False, default=20,
                        help="int. The length of crRNA, default = 20.")
    parser.add_argument("-pl", metavar='the Range of Primer Length', type=str, required=False, default='28,35',
                        help="str. The range of primer length, default = 28,35.")
    parser.add_argument("-cct", metavar="crRNA Conserve Threshold", type=float, required=False, default=0.99,
                        help="float, default value is 0.99.")

    parser.add_argument("-pct", metavar="Primer Conserve Threshold", type=float, required=False, default=0.99,
                        help="float, default value is 0.99.")
    parser.add_argument("-pst", metavar="Primer Specificity Threshold", type=float, required=False, default=0.3,
                        help="float, The minimum ratio of mismatched "
                             "bases allowed between the primer and "
                             "the background genome, default value is 0.3.")
    parser.add_argument("-n", type=int, required=False, default=8, help="The number of processes, default=8.")
    parser.add_argument("-range", type=str, required=False, help="The range of conversed seq to search crRNA&primer.")
    parser.add_argument("--bgfile", type=str, required=False, nargs="+", help="Path of background fasta file(one or "
                                                                              "multiple files separated by spaces) for "
                                                                              "the Primer or crRNA specificity "
                                                                              "screening.")
    # parser.add_argument("--test-crRNA", type=str, required=False, help="test the crRNA")
    # parser.add_argument("--test-primer", type=str, required=False, help="test the primer")

    return parser.parse_args()


def check_fasta_file(filename):
    with open(filename, "r") as f:

        lines = f.readlines()
        num_name_lines = sum([1 for line in lines if line.startswith(">")])

        if num_name_lines > 1:
            return True
        else:
            return False


def search_crRNA_in_bgfile_pos(bgfile_seq):
    crRNA_list = []
    crRNA_list_noPAM = []

    crRNA_list = crRNA_list + \
                 re.findall(r'[ACG]TT[ACG][ATCG]{}'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                 re.findall(r'T[ACG]T[ACG][ATCG]{}'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                 re.findall(r'TT[ACG][ACG][ATCG]{}'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                 re.findall(r'TTT[ACG][ATCG]{}'.format('{' + str(args.cl) + '}'), bgfile_seq)

    for crRNA in crRNA_list:
        crRNA_list_noPAM.append(crRNA[4:])

    return crRNA_list_noPAM


def search_crRNA_in_bgfile_rev(bgfile_seq):
    crRNA_list = []
    crRNA_list_noPAM = []

    for bgfile_seq in bgfile_seqs:
        crRNA_list = crRNA_list + \
                     re.findall(r'[ATCG]{}[TCG]AA[TCG]'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                     re.findall(r'[ATCG]{}A[TCG]A[TCG]'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                     re.findall(r'[ATCG]{}AA[TCG][TCG]'.format('{' + str(args.cl) + '}'), bgfile_seq) + \
                     re.findall(r'[ATCG]{}AAA[TCG]'.format('{' + str(args.cl) + '}'), bgfile_seq)

    for crRNA in crRNA_list:
        crRNA_list_noPAM.append(crRNA[0:args.cl])

    return crRNA_list_noPAM


def crRNA_specificity_pos(crRNA):
    crRNA_noPAM = crRNA[4:]
    crRNA_noPAM_15bp_list = specificity.str_split_n(crRNA_noPAM, 15)
    result = [crRNA, 1.001]

    for crRNA_15bp in crRNA_noPAM_15bp_list:

        for bg_seq in bgfile_seqs:

            if crRNA_15bp in bg_seq:

                bg_15bp_pos = bg_seq.find(crRNA_15bp)
                bg_15bp_pos_list = []

                while bg_15bp_pos != -1:
                    bg_15bp_pos_list.append(bg_15bp_pos)
                    bg_15bp_pos = bg_seq.find(crRNA_15bp, bg_15bp_pos + 15)

                for pos in bg_15bp_pos_list:
                    test_PAM = bg_seq[pos - crRNA.find(crRNA_15bp):pos - crRNA.find(crRNA_15bp) + 4]

                    if test_PAM[0:3] == "TTT":
                        hanming = specificity.get_hanming(crRNA[4:], bg_seq[
                                                                     pos - crRNA.find(crRNA_15bp) + 4:pos - crRNA.find(
                                                                         crRNA_15bp) + 4 + args.cl])

                        if hanming > 2:
                            result[1] = args.cct - 0.001

                        elif hanming > 1 and specificity.get_hanming(crRNA[4:9], bg_seq[pos - crRNA.find(
                                crRNA_15bp) + 4:pos - crRNA.find(crRNA_15bp) + 4 + 5]) > 0:
                            result[1] = args.cct - 0.001

                        else:
                            result[1] = 0

                    else:
                        result[1] = round((1 + args.cct) / 2, 3)

    return result


def crRNA_specificity_rev(crRNA):
    crRNA_noPAM = crRNA[0:args.cl]
    crRNA_noPAM_15bp_list = specificity.str_split_n(crRNA_noPAM, 15)
    result = [crRNA, 1.001]

    for crRNA_15bp in crRNA_noPAM_15bp_list:

        for bg_seq in bgfile_seqs:

            if crRNA_15bp in bg_seq:

                bg_15bp_pos = bg_seq.find(crRNA_15bp)
                bg_15bp_pos_list = []

                while bg_15bp_pos != -1:
                    bg_15bp_pos_list.append(bg_15bp_pos)
                    bg_15bp_pos = bg_seq.find(crRNA_15bp, bg_15bp_pos + 15)

                for pos in bg_15bp_pos_list:
                    test_PAM = bg_seq[pos + args.cl - crRNA.find(crRNA_15bp):pos + args.cl - crRNA.find(crRNA_15bp) + 4]

                    if test_PAM[1:4] == "AAA":
                        hanming = specificity.get_hanming(crRNA[0:args.cl], bg_seq[pos - crRNA.find(
                            crRNA_15bp):pos + args.cl - crRNA.find(crRNA_15bp)])

                        if hanming > 2:
                            result[1] = args.cct - 0.001

                        elif hanming > 1 and specificity.get_hanming(crRNA[-9:-4], bg_seq[pos + args.cl -
                                                                                          crRNA.find(
                                                                                              crRNA_15bp) - 5:pos + args.cl - crRNA.find(
                            crRNA_15bp)]) > 0:
                            result[1] = args.cct - 0.001

                        else:
                            result[1] = 0

                    else:
                        result[1] = round((1 + args.cct) / 2, 3)

    return result


def conserved_sequence_specificity_filtering_crRNA(crRNA_seq):
    crRNA_seq_rev = specificity.reverse_complement(crRNA_seq)
    for bg_seq in bgfile_seqs:

        if crRNA_seq in bg_seq:
            return crRNA_seq
        elif crRNA_seq_rev in bg_seq:
            return crRNA_seq


def specificity_filtering_primer(primer):
    hanming_dist = len(primer)
    length = len(primer)
    seq_rev = specificity.reverse_complement(primer)
    for bgfile_seq in bgfile_seqs:

        for i in range(0, len(bgfile_seq) - length):
            bg_seq = bgfile_seq[i:i + length]
            hanming_pos = specificity.get_hanming(bg_seq, primer)
            hanming_rev = specificity.get_hanming(bg_seq, seq_rev)
            hanming_dist_test = min(hanming_pos, hanming_rev)

            if hanming_dist_test < hanming_dist:
                hanming_dist = hanming_dist_test
            if hanming_dist / length <= args.pst:
                break

        if hanming_dist / length <= args.pst:
            break
    return [primer, hanming_dist / length]


if __name__ == '__main__':

    time_start = time.time()

    args = parse_args()

    if not os.path.exists(args.i):
        logging.error(f"File '{args.i}' does not exist, please check it.")
        sys.exit(1)

    result_folder = "./{}".format(args.i.split('.')[0])
    if not os.path.exists(result_folder):
        os.mkdir(result_folder)

    # Configure the logging system
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s %(levelname)s %(message)s',
                        filename=result_folder + '/CORDS42.log',
                        filemode='w')
    # Output log messages to the console
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    formatter = logging.Formatter('%(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

    # get and check arguments

    logging.info("arguments: " + str(vars(args)))

    bgfiles = []
    if args.bgfile:
        for file in args.bgfile:
            if not os.path.exists(file):
                logging.error(f"File '{file}' does not exist, please check it.")
                sys.exit(1)

        for file in args.bgfile:
            bgfiles = sorted(args.bgfile, key=os.path.getsize)

    if args.t != 'fasta' and args.t != 'MSA_fasta':
        logging.error("argument '-t' error, please check it.")
        sys.exit(1)

    if 0.5 < args.cct <= 1:
        pass
    else:
        logging.error("argument '-cct' error, please check it.")
        sys.exit(1)

    if 0.5 < args.pct <= 1:
        pass
    else:
        logging.error("argument '-pct' error, please check it.")
        sys.exit(1)

    try:
        pl = [int(args.pl.split(',')[0]), int(args.pl.split(',')[1])]
    except:
        logging.error("argument '-pl' error, please check it.")
        sys.exit(1)

    n = args.n
    max_processes = multiprocessing.cpu_count()
    if max_processes <= 9:
        n = max_processes - 1

    if args.t == "fasta":

        if check_fasta_file(args.i):
            logging.info("Start sequence conservation analysis.")
            try:
                seq, conservation_scores = conserve.Conserve(args.i)
            except Exception as e:
                logging.error("An error occurred: %s", str(e))
                sys.exit(1)

        else:
            logging.error("Please enter multiple DNA sequences to calculate conservation.")
            sys.exit(1)

    else:
        seq, conservation_scores = conserve.get_seq_conservation_scores(args.i)

    if args.range:
        seq = seq[int(args.range.split(',')[0]):int(args.range.split(',')[1])]
        conservation_scores = conservation_scores[int(args.range.split(',')[0]):int(args.range.split(',')[1])]

    # get crRNAs
    logging.info("Start searching for crRNAs suitable for one-pot RPA reaction.")
    logging.info("Check crRNA‘s conservation, CG content, secondary structure.")

    # dict, {crRNA_seq:[start pos, end pos, conserve score, CG content, min free energy]}
    # positive
    VTTV = crRNAs.get_crRNAs(seq, "VTTV", args.cl)
    VTTV = crRNAs.crRNA_1st_filtering_pos(VTTV, seq, conservation_scores, args.cct)

    TVTV = crRNAs.get_crRNAs(seq, "TVTV", args.cl)
    TVTV = crRNAs.crRNA_1st_filtering_pos(TVTV, seq, conservation_scores, args.cct)

    TTVN = crRNAs.get_crRNAs(seq, "TTVN", args.cl)
    TTVN = crRNAs.crRNA_1st_filtering_pos(TTVN, seq, conservation_scores, args.cct)

    TTTV = crRNAs.get_crRNAs(seq, "TTTV", args.cl)
    TTTV = crRNAs.crRNA_1st_filtering_pos(TTTV, seq, conservation_scores, args.cct)

    TTTT = crRNAs.get_crRNAs(seq, "TTTT", args.cl)
    TTTT = crRNAs.crRNA_1st_filtering_pos(TTTT, seq, conservation_scores, args.cct)


    # reverse
    BAAB = crRNAs.get_crRNAs(seq, "BAAB", args.cl)
    BAAB = crRNAs.crRNA_1st_filtering_rev(BAAB, seq, conservation_scores, args.cct, args.cl)

    BABA = crRNAs.get_crRNAs(seq, "BABA", args.cl)
    BABA = crRNAs.crRNA_1st_filtering_rev(BABA, seq, conservation_scores, args.cct, args.cl)

    NBAA = crRNAs.get_crRNAs(seq, "NBAA", args.cl)
    NBAA = crRNAs.crRNA_1st_filtering_rev(NBAA, seq, conservation_scores, args.cct, args.cl)

    BAAA = crRNAs.get_crRNAs(seq, "BAAA", args.cl)
    BAAA = crRNAs.crRNA_1st_filtering_rev(BAAA, seq, conservation_scores, args.cct, args.cl)

    AAAA = crRNAs.get_crRNAs(seq, "AAAA", args.cl)
    AAAA = crRNAs.crRNA_1st_filtering_rev(AAAA, seq, conservation_scores, args.cct, args.cl)

    crRNA_dict_pos = {**VTTV, **TVTV, **TTVN, **TTTV, **TTTT}  # ** mean depack the dict
    crRNA_dict_rev = {**BAAB, **BABA, **NBAA, **BAAA, **AAAA}

    crRNA_count = 0
    for crRNA_dict in [crRNA_dict_pos, crRNA_dict_rev]:
        crRNA_count += len(crRNA_dict)

    if crRNA_count < 1:
        logging.error("There is no enough conserved crRNAs, please check the crRNA argument.")
        sys.exit(1)
    elif crRNA_count > 300:
        logging.info(
            "There is too much conserved crRNAs, may take a very long time for specificity filtering, "
            "Recommended adjsuting the crRNA argument.")
    logging.info("number of conserved potential crRNAs: " + str(crRNA_count))

    # crRNAs specific filtering
    logging.info("Specificity filtering of potential crRNAs, it may takes a long time.")
    # logging.info("Read sequences from background files.")

    bgfile_seqs = []
    if args.bgfile:
        # get seqs in bgfiles
        for bgfile in bgfiles:
            bgfile_records = SeqIO.parse(bgfile, 'fasta')

            for bgfile_record in bgfile_records:
                bgfile_seqs.append(str(bgfile_record.seq).upper())

    pool = multiprocessing.Pool(n)
    # search crRNAs in bg files
    # logging.info("Search crRNAs from background files.")

    if args.bgfile:
        #
        # crRNAs_in_bgfiles_pos = []
        # crRNAs_in_bgfiles_rev = []

        # r_pos = pool.map_async(search_crRNA_in_bgfile_pos, bgfile_seqs)
        #
        # for l in r_pos.get():
        #     crRNAs_in_bgfiles_pos = crRNAs_in_bgfiles_pos + l
        #
        # r_rev = pool.map_async(search_crRNA_in_bgfile_pos, bgfile_seqs)
        #
        # for l in r_rev.get():
        #     crRNAs_in_bgfiles_rev = crRNAs_in_bgfiles_pos + l

        # crRNA specificity filtering

        pool1_list_pos = []
        for key in crRNA_dict_pos:
            pool1_list_pos.append(key)

        r1_pos = pool.map_async(crRNA_specificity_pos, pool1_list_pos)

        for l in r1_pos.get():
            crRNA = l[0]
            specificity_score = l[1]

            if specificity_score == 0:

                if crRNA in VTTV:
                    del VTTV[crRNA]

                elif crRNA in TVTV:
                    del TVTV[crRNA]

                elif crRNA in TTVN:
                    del TTVN[crRNA]

                elif crRNA in TTTT:
                    del TTTT[crRNA]

                elif crRNA in TTTV:
                    del TTTV[crRNA]

            else:
                if crRNA in VTTV:
                    VTTV[crRNA].append(specificity_score)

                elif crRNA in TVTV:
                    TVTV[crRNA].append(specificity_score)

                elif crRNA in TTVN:
                    TTVN[crRNA].append(specificity_score)

                elif crRNA in TTTT:
                    TTTT[crRNA].append(specificity_score)

                elif crRNA in TTTV:
                    TTTV[crRNA].append(specificity_score)

        pool1_list_rev = []
        for key in crRNA_dict_rev:
            pool1_list_rev.append(key)

        r1_rev = pool.map_async(crRNA_specificity_rev, pool1_list_rev)

        pool.close()
        pool.join()

        for l in r1_rev.get():
            crRNA = l[0]
            specificity_score = l[1]

            if specificity_score == 0:

                if crRNA in BAAB:
                    del BAAB[crRNA]

                elif crRNA in BABA:
                    del BABA[crRNA]

                elif crRNA in NBAA:
                    del NBAA[crRNA]

                elif crRNA in AAAA:
                    del AAAA[crRNA]

                elif crRNA in BAAA:
                    del BAAA[crRNA]

            else:
                if crRNA in BAAB:
                    BAAB[crRNA].append(specificity_score)

                elif crRNA in BABA:
                    BABA[crRNA].append(specificity_score)

                elif crRNA in NBAA:
                    NBAA[crRNA].append(specificity_score)

                elif crRNA in AAAA:
                    AAAA[crRNA].append(specificity_score)

                elif crRNA in BAAA:
                    BAAA[crRNA].append(specificity_score)
    # dict {PAM+crRNA : start pos, end pos, conserve, CG content, min free energy, specificity score}

    crRNA_dict_pos = {**VTTV, **TVTV, **TTVN, **TTTV, **TTTT}
    crRNA_dict_rev = {**BAAB, **BABA, **NBAA, **BAAA, **AAAA}

    crRNA_count = 0
    for crRNA_dict in [crRNA_dict_pos, crRNA_dict_rev]:
        crRNA_count += len(crRNA_dict)

    if crRNA_count < 1:
        logging.error("There is no enough conserved & specific crRNAs, please check the argument: -cct -cl.")
        sys.exit(1)
    logging.info("number of conserved potential & specific crRNAs: " + str(crRNA_count))

    # get primer range of the consensus sequence
    crRNA_start_pos_list = []
    for crRNA_dict in [crRNA_dict_pos, crRNA_dict_rev]:
        for key in crRNA_dict:
            crRNA_start_pos_list.append(crRNA_dict[key][0])
    crRNA_start_pos_list.sort()

    primer_range_pos = []
    pos_test_list = []
    last_pos = crRNA_start_pos_list[0]

    for pos in crRNA_start_pos_list:

        if pos - last_pos <= 400 - args.cl - 4:
            pos_test_list.append(pos)

        else:
            primer_range_pos.append(pos_test_list)
            pos_test_list = [pos]

        last_pos = pos

    primer_range_pos.append(pos_test_list)

    primer_range = []

    for pos_list in primer_range_pos:
        primer_range.append([max(min(pos_list) - 200 + args.cl, 0), min(max(pos_list) + 200, len(seq))])

    logging.info("The range of searching primers are {}.".format(str(primer_range)))

    # get Primers
    primer_dict = {}
    logging.info("Start searching for primers suitable for one-pot RPA reaction.")
    logging.info("Check primer's conservation, CG content, secondary structure, consecutive CG bases.")

    # dict, {primer_seq:[start pos, end pos, conserve score, CG content, min free energy]}
    test_primer_dict = {}
    for single_primer_range in primer_range:
        test_primer_dict = primers.get_primers(seq[single_primer_range[0]:single_primer_range[1]],
                                               conservation_scores[single_primer_range[0]:single_primer_range[1]],
                                               args.pct, seq, pl)
        primer_dict.update(test_primer_dict)

    if len(primer_dict) < 2:
        logging.error("There is no enough conserved primers, please check the primer argument.")
        sys.exit(1)
    if len(primer_dict) > 500:
        logging.info("There is too much conserved primers, Recommended adjsuting the primer argument.")
    logging.info("number of conserved potential primers: " + str(len(primer_dict)))

    logging.info("Specificity filtering of primers, it may takes a long time.")

    if args.bgfile:
        primer_spec_folder = './primer_spec'
        if not os.path.exists(primer_spec_folder):
            os.mkdir(primer_spec_folder)

        bg_fasta = open(primer_spec_folder + '/bg.fasta', 'w')
        for i in range(0, len(bgfile_seqs)):
            bg_fasta.write('>' + str(i) + '\n')
            bg_fasta.write(bgfile_seqs[i] + '\n\n')
        bg_fasta.close()

        makedb_cmd = "makeblastdb -dbtype nucl -in {} -out {}".format(primer_spec_folder + '/bg.fasta',
                                                                      primer_spec_folder + '/bg_db')
        process = subprocess.Popen(makedb_cmd, shell=True,
                                   stdout=subprocess.PIPE)  # shell=True ensure the workspace is right
        output = process.communicate()  # wait for subprocess end

        primer_dict_fa = open(primer_spec_folder + '/query.fasta', 'w')
        primer_seq_id_dict = {}
        id = 1
        for key in primer_dict:
            primer_seq_id_dict[str(id)] = key
            primer_dict_fa.write('>' + str(id) + '\n')
            primer_dict_fa.write(key + '\n')
            id += 1
        primer_dict_fa.close()

        blastn_cmd = "blastn -query {} -db {} -max_target_seqs 1 -outfmt 6 -num_threads {} -word_size 4 -gapopen 5 " \
                     "-gapextend 2 -reward 1 -penalty -2 -max_hsps 1 -out {}".format(
            primer_spec_folder + '/query.fasta', primer_spec_folder + '/bg_db', str(n),
            primer_spec_folder + '/result.txt')

        process = subprocess.Popen(blastn_cmd, shell=True,
                                   stdout=subprocess.PIPE
                                   , stderr=subprocess.DEVNULL)  # shell=True ensure the workspace is right
        output = process.communicate()  # wait for subprocess end

        with open(primer_spec_folder + '/result.txt', 'r') as f:
            for line in f:
                line_split = line.split('\t')
                key = primer_seq_id_dict[line_split[0]]
                score = 1 - ((int(line_split[3]) - int(line_split[4]) - int(line_split[5])) / len(key))
                if score < args.pst:
                    del primer_dict[key]
                else:
                    primer_dict[key].append(score)

        for key in primer_dict:
            if len(primer_dict[key]) < 6:
                primer_dict[key].append(1.0)

        del_cmd = 'rm -f -r {}'.format(primer_spec_folder + '/')
        process = subprocess.Popen(del_cmd, shell=True,
                                   stdout=subprocess.PIPE)  # shell=True ensure the workspace is right
        output = process.communicate()  # wait for subprocess end

    logging.info("number of conserved & specific potential primers: " + str(len(primer_dict)))
    # dict, {primer_seq:[start pos, end pos, conserve score, CG content, min free energy, mismatch ratio]}
    if len(primer_dict) < 2:
        logging.error("There is no enough specific primers, please check the arguments: -pst.")
        sys.exit(1)

    # result output

    with open(result_folder + '/' + 'primer_summary.txt', 'w') as f:
        for key in primer_dict:
            f.write(key + str(primer_dict[key]) + '\n')

    AAAA_new = {}
    for key in AAAA:
        key_rev = specificity.reverse_complement(key)
        AAAA_new[key_rev] = AAAA[key]

    NBAA_new = {}
    for key in NBAA:
        key_rev = specificity.reverse_complement(key)
        NBAA_new[key_rev] = NBAA[key]

    BAAB_new = {}
    for key in BAAB:
        key_rev = specificity.reverse_complement(key)
        BAAB_new[key_rev] = BAAB[key]

    BABA_new = {}
    for key in BABA:
        key_rev = specificity.reverse_complement(key)
        BABA_new[key_rev] = BABA[key]

    BAAA_new = {}
    for key in BAAA:
        key_rev = specificity.reverse_complement(key)
        BAAA_new[key_rev] = BAAA[key]

    best_sPAM_crRNA_dict = {**TTTT, **AAAA_new, **NBAA_new, **TTVN, **VTTV, **BAAB_new, **TVTV, **BABA_new}
    best_sPAM_crRNA_list = sorted(best_sPAM_crRNA_dict.items(), key=lambda x: (x[1][2] + x[1][5]), reverse=True)

    # better_sPAM_crRNA_dict = {**TTTT, **AAAA}
    # better_sPAM_crRNA_list = sorted(better_sPAM_crRNA_dict.items(), key=lambda x: (x[1][2] + x[1][5]), reverse=True)

    good_cPAM_crRNA_dict = {**TTTV, **BAAA_new}
    good_cPAM_crRNA_list = sorted(good_cPAM_crRNA_dict.items(), key=lambda x: (x[1][2] + x[1][5]), reverse=True)

    Total_crRNA_list = best_sPAM_crRNA_list + good_cPAM_crRNA_list

    with open(result_folder + '/' + "crRNA_summary.txt", "w") as f:
        for l in Total_crRNA_list:
            f.write(str(l) + '\n')

    rank_count = 1
    result_count = 0
    for crRNA in Total_crRNA_list:
        crRNA_seq, start_pos, end_pos, conservation_score, CG_content, min_free_energy, specificity_score = crRNA[0], crRNA[1][0], crRNA[1][1], crRNA[1][2], crRNA[1][3], crRNA[1][4], crRNA[1][5]

        specificity_text = ""
        if specificity_score == args.cct - 0.001:
            specificity_text = "consecutive homologous nucleotides >= 15, but there are 3 mismatches or 2 mismatches " \
                               "& mismatch in the seed region. "

        elif specificity_score == round((1 + args.cct) / 2, 3):
            specificity_text = "consecutive homologous nucleotides >= 15, but there is no classic PAM nearby."

        elif specificity_score == 1.001:
            specificity_text = "consecutive homologous nucleotides < 15"

        crRNA_primers_dict_up = {}
        crRNA_primers_dict_down = {}
        for key in primer_dict:
            if end_pos - 200 <= primer_dict[key][0] and primer_dict[key][1] <= start_pos:
                crRNA_primers_dict_up[key] = primer_dict[key]
            elif start_pos + 200 - len(key) >= primer_dict[key][0] >= end_pos:
                crRNA_primers_dict_down[key] = primer_dict[key]

        if len(crRNA_primers_dict_up) < 1 or len(crRNA_primers_dict_down) < 1:
            continue

        crRNA_primers_list_up = sorted(crRNA_primers_dict_up.items(), key=lambda x: (x[1][2] + x[1][5]), reverse=True)
        crRNA_primers_list_dwon = sorted(crRNA_primers_dict_down.items(), key=lambda x: (x[1][2] + x[1][5]), reverse=True)

        with open(result_folder + '/' + str(rank_count) + '-' + crRNA_seq + '.csv', 'w') as f:
            f.write(
                'crRNA(with PAM), start pos, end pos, conserve_score, CG content, min free energy, specificity\n')
            f.write(
                crRNA_seq + ',' + str(start_pos) + ',' + str(end_pos) + ',' + str(conservation_score) + ',' + str(CG_content) + ',' +
                str(min_free_energy) + ',' + specificity_text + '\n\n')

            f.write("\nThe upstream sequence primers matching this crRNA are listed below\n")
            f.write(
                'primer seq, start pos, end pos, conserve_score, CG content, min free energy, mismatch ratio\n')
            for primer in crRNA_primers_list_up:
                f.write(
                    primer[0] + ',' + str(primer[1][0]) + ',' + str(primer[1][1]) + ',' + str(
                        primer[1][2]) + ',' + str(primer[1][3]) + ',' + str(primer[1][4]) + ',' + str(
                        primer[1][5]) + '\n')

            f.write("\nThe downstream sequence primers matching this crRNA are listed below\n")
            f.write(
                'primer seq, start pos, end pos, conserve_score, CG content, min free energy, mismatch ratio\n')
            for primer in crRNA_primers_list_dwon:
                f.write(
                    primer[0] + ',' + str(primer[1][0]) + ',' + str(primer[1][1]) + ',' + str(
                        primer[1][2]) + ',' + str(primer[1][3]) + ',' + str(primer[1][4]) + ',' + str(
                        primer[1][5]) + '\n')

        rank_count += 1
        result_count += 1

    if result_count == 0:
        logging.error("There is no paired crRNAs and primers, please check the arguments.")
        sys.exit(1)

    time_end = time.time()
    time_sum = time_end - time_start
    logging.info("Total time: " + str(time_sum))
